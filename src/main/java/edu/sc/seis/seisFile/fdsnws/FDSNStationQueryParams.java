
package edu.sc.seis.seisFile.fdsnws;

import java.time.Instant;
import picocli.CommandLine.Option;

import edu.sc.seis.seisFile.fdsnws.stationxml.Channel;
import edu.sc.seis.seisFile.ChannelTimeWindow;
import edu.sc.seis.seisFile.TimeUtils;
import edu.sc.seis.seisFile.client.*;

/** Autogenerated by groovy FDSNQueryParamGenerator.groovy in src/metacode/groovy
 */
public class FDSNStationQueryParams extends AbstractQueryParams implements Cloneable {

    public FDSNStationQueryParams() {
        this(DEFAULT_HOST);
    }

    public FDSNStationQueryParams(String host) {
        super(host==null ? DEFAULT_HOST : host);
    }

    public FDSNStationQueryParams clone() {
        FDSNStationQueryParams out = new FDSNStationQueryParams(getHost());
        out.cloneNonParams(this);
        for (String key : params.keySet()) {
            out.setParam(key, params.get(key));
        }
        return out;
    }

    public FDSNStationQueryParams setHost(String host) {
        this.host = host;
        return this;
    }


    public static final String STARTTIME = "starttime";

    public static final String STARTTIME_SHORT = "start";


    public FDSNStationQueryParams clearStartTime() {
        clearParam(STARTTIME);
        return this;
    }

    /** Limit to metadata epochs startingon or after the specified start time.
     */
    @Option(names = { "-b","--starttime","--start" }, description="Limit to metadata epochs startingon or after the specified start time.", converter=CeilingISOTimeParser.class)
    public FDSNStationQueryParams setStartTime(Instant value) {
        setParam(STARTTIME, value);
        return this;
    }


    public static final String ENDTIME = "endtime";

    public static final String ENDTIME_SHORT = "end";


    public FDSNStationQueryParams clearEndTime() {
        clearParam(ENDTIME);
        return this;
    }

    /** Limit to metadata epochs ending on or before the specified end time.
     */
    @Option(names = { "-e","--endtime","--end" }, description="Limit to metadata epochs ending on or before the specified end time.", converter=FloorISOTimeParser.class)
    public FDSNStationQueryParams setEndTime(Instant value) {
        setParam(ENDTIME, value);
        return this;
    }


    public static final String STARTBEFORE = "startbefore";



    public FDSNStationQueryParams clearStartBefore() {
        clearParam(STARTBEFORE);
        return this;
    }

    /** Limit to metadata epochs starting before specified time.
     */
    @Option(names = { "--startbefore" }, description="Limit to metadata epochs starting before specified time.", converter=CeilingISOTimeParser.class)
    public FDSNStationQueryParams setStartBefore(Instant value) {
        setParam(STARTBEFORE, value);
        return this;
    }


    public static final String STARTAFTER = "startafter";



    public FDSNStationQueryParams clearStartAfter() {
        clearParam(STARTAFTER);
        return this;
    }

    /** Limit to metadata epochs starting after specified time.
     */
    @Option(names = { "--startafter" }, description="Limit to metadata epochs starting after specified time.", converter=CeilingISOTimeParser.class)
    public FDSNStationQueryParams setStartAfter(Instant value) {
        setParam(STARTAFTER, value);
        return this;
    }


    public static final String ENDBEFORE = "endbefore";



    public FDSNStationQueryParams clearEndBefore() {
        clearParam(ENDBEFORE);
        return this;
    }

    /** Limit to metadata epochs ending before specified time.
     */
    @Option(names = { "--endbefore" }, description="Limit to metadata epochs ending before specified time.", converter=FloorISOTimeParser.class)
    public FDSNStationQueryParams setEndBefore(Instant value) {
        setParam(ENDBEFORE, value);
        return this;
    }


    public static final String ENDAFTER = "endafter";



    public FDSNStationQueryParams clearEndAfter() {
        clearParam(ENDAFTER);
        return this;
    }

    /** Limit to metadata epochs ending after specified time.
     */
    @Option(names = { "--endafter" }, description="Limit to metadata epochs ending after specified time.", converter=FloorISOTimeParser.class)
    public FDSNStationQueryParams setEndAfter(Instant value) {
        setParam(ENDAFTER, value);
        return this;
    }


    public static final String NETWORK = "network";

    public static final String NETWORK_SHORT = "net";


    public FDSNStationQueryParams clearNetwork() {
        clearParam(NETWORK);
        return this;
    }


    /** Select one or more network codes. Can be SEED network codes or data center defined codes. Multiple codes are comma-separated.
     */
    @Option(names = { "-n","--network","--net" }, description="Select one or more network codes. Can be SEED network codes or data center defined codes. Multiple codes are comma-separated.")
    public FDSNStationQueryParams setNetwork(String[] value) {
        clearNetwork();
        for(String v: value) appendToNetwork(v);
        return this;
    }

    public FDSNStationQueryParams appendToNetwork(String value) {
        appendToParam(NETWORK, value);
        return this;
    }


    public static final String STATION = "station";

    public static final String STATION_SHORT = "sta";


    public FDSNStationQueryParams clearStation() {
        clearParam(STATION);
        return this;
    }


    /** Select one or more SEED station codes. Multiple codes are comma-separated.
     */
    @Option(names = { "-s","--station","--sta" }, description="Select one or more SEED station codes. Multiple codes are comma-separated.")
    public FDSNStationQueryParams setStation(String[] value) {
        clearStation();
        for(String v: value) appendToStation(v);
        return this;
    }

    public FDSNStationQueryParams appendToStation(String value) {
        appendToParam(STATION, value);
        return this;
    }


    public static final String LOCATION = "location";

    public static final String LOCATION_SHORT = "loc";


    public FDSNStationQueryParams clearLocation() {
        clearParam(LOCATION);
        return this;
    }


    /** Select one or more SEED location identifiers. Multiple identifiers are comma-separated. As a special case -- (two dashes) will be translated to a string of two space characters to match blank location IDs.
     */
    @Option(names = { "-l","--location","--loc" }, description="Select one or more SEED location identifiers. Multiple identifiers are comma-separated. As a special case -- (two dashes) will be translated to a string of two space characters to match blank location IDs.")
    public FDSNStationQueryParams setLocation(String[] value) {
        clearLocation();
        for(String v: value) appendToLocation(v);
        return this;
    }

    public FDSNStationQueryParams appendToLocation(String value) {
        if (value == null || Channel.EMPTY_LOC_CODE.equals(value.trim())) { value = "--";}
        appendToParam(LOCATION, value);
        return this;
    }


    public static final String CHANNEL = "channel";

    public static final String CHANNEL_SHORT = "cha";


    public FDSNStationQueryParams clearChannel() {
        clearParam(CHANNEL);
        return this;
    }


    /** Select one or more SEED channel codes. Multiple codes are comma-separated.
     */
    @Option(names = { "-c","--channel","--cha" }, description="Select one or more SEED channel codes. Multiple codes are comma-separated.")
    public FDSNStationQueryParams setChannel(String[] value) {
        clearChannel();
        for(String v: value) appendToChannel(v);
        return this;
    }

    public FDSNStationQueryParams appendToChannel(String value) {
        appendToParam(CHANNEL, value);
        return this;
    }


    public static final String MINLATITUDE = "minlatitude";

    public static final String MINLATITUDE_SHORT = "minlat";


    public FDSNStationQueryParams clearMinLatitude() {
        clearParam(MINLATITUDE);
        return this;
    }

    /** Limit to stations with a latitude larger than the specified minimum.
     */
    @Option(names = { "--minlatitude","--minlat" }, description="Limit to stations with a latitude larger than the specified minimum.")
    public FDSNStationQueryParams setMinLatitude(float value) {
        setParam(MINLATITUDE, value);
        return this;
    }


    public static final String MAXLATITUDE = "maxlatitude";

    public static final String MAXLATITUDE_SHORT = "maxlat";


    public FDSNStationQueryParams clearMaxLatitude() {
        clearParam(MAXLATITUDE);
        return this;
    }

    /** Limit to stations with a latitude smaller than the specified maximum.
     */
    @Option(names = { "--maxlatitude","--maxlat" }, description="Limit to stations with a latitude smaller than the specified maximum.")
    public FDSNStationQueryParams setMaxLatitude(float value) {
        setParam(MAXLATITUDE, value);
        return this;
    }


    public static final String MINLONGITUDE = "minlongitude";

    public static final String MINLONGITUDE_SHORT = "minlon";


    public FDSNStationQueryParams clearMinLongitude() {
        clearParam(MINLONGITUDE);
        return this;
    }

    /** Limit to stations with a longitude larger than the specified minimum.
     */
    @Option(names = { "--minlongitude","--minlon" }, description="Limit to stations with a longitude larger than the specified minimum.")
    public FDSNStationQueryParams setMinLongitude(float value) {
        setParam(MINLONGITUDE, value);
        return this;
    }


    public static final String MAXLONGITUDE = "maxlongitude";

    public static final String MAXLONGITUDE_SHORT = "maxlon";


    public FDSNStationQueryParams clearMaxLongitude() {
        clearParam(MAXLONGITUDE);
        return this;
    }

    /** Limit to stations with a longitude smaller than the specified maximum.
     */
    @Option(names = { "--maxlongitude","--maxlon" }, description="Limit to stations with a longitude smaller than the specified maximum.")
    public FDSNStationQueryParams setMaxLongitude(float value) {
        setParam(MAXLONGITUDE, value);
        return this;
    }


    public static final String LATITUDE = "latitude";

    public static final String LATITUDE_SHORT = "lat";


    public FDSNStationQueryParams clearLatitude() {
        clearParam(LATITUDE);
        return this;
    }

    /** Specify the latitude to be used for a radius search.
     */
    @Option(names = { "--latitude","--lat" }, description="Specify the latitude to be used for a radius search.")
    public FDSNStationQueryParams setLatitude(float value) {
        setParam(LATITUDE, value);
        return this;
    }


    public static final String LONGITUDE = "longitude";

    public static final String LONGITUDE_SHORT = "lon";


    public FDSNStationQueryParams clearLongitude() {
        clearParam(LONGITUDE);
        return this;
    }

    /** Specify the longitude to the used for a radius search.
     */
    @Option(names = { "--longitude","--lon" }, description="Specify the longitude to the used for a radius search.")
    public FDSNStationQueryParams setLongitude(float value) {
        setParam(LONGITUDE, value);
        return this;
    }


    public static final String MINRADIUS = "minradius";



    public FDSNStationQueryParams clearMinRadius() {
        clearParam(MINRADIUS);
        return this;
    }

    /** Limit results to stations within the specified minimum number of degrees from the geographic point defined by the latitude and longitude parameters.
     */
    @Option(names = { "--minradius" }, description="Limit results to stations within the specified minimum number of degrees from the geographic point defined by the latitude and longitude parameters.")
    public FDSNStationQueryParams setMinRadius(float value) {
        setParam(MINRADIUS, value);
        return this;
    }


    public static final String MAXRADIUS = "maxradius";



    public FDSNStationQueryParams clearMaxRadius() {
        clearParam(MAXRADIUS);
        return this;
    }

    /** Limit results to stations within the specified maximum number of degrees from the geographic point defined by the latitude and longitude parameters.
     */
    @Option(names = { "--maxradius" }, description="Limit results to stations within the specified maximum number of degrees from the geographic point defined by the latitude and longitude parameters.")
    public FDSNStationQueryParams setMaxRadius(float value) {
        setParam(MAXRADIUS, value);
        return this;
    }


    public static final String LEVEL = "level";



    public FDSNStationQueryParams clearLevel() {
        clearParam(LEVEL);
        return this;
    }

    /** Specify the level of detail for the results.
     */
    @Option(names = { "-L","--level" }, description="Specify the level of detail for the results.")
    public FDSNStationQueryParams setLevel(String value) {
        setParam(LEVEL, value);
        return this;
    }


    public static final String INCLUDERESTRICTED = "includerestricted";



    public FDSNStationQueryParams clearIncludeRestricted() {
        clearParam(INCLUDERESTRICTED);
        return this;
    }

    /** Specify if results should include information for restricted stations.
     */
    @Option(names = { "--includerestricted" }, description="Specify if results should include information for restricted stations.")
    public FDSNStationQueryParams setIncludeRestricted(boolean value) {
        setParam(INCLUDERESTRICTED, value);
        return this;
    }


    public static final String INCLUDEAVAILABILITY = "includeavailability";



    public FDSNStationQueryParams clearIncludeAvailability() {
        clearParam(INCLUDEAVAILABILITY);
        return this;
    }

    /** Specify if results should include information about time series data availability.
     */
    @Option(names = { "--includeavailability" }, description="Specify if results should include information about time series data availability.")
    public FDSNStationQueryParams setIncludeAvailability(boolean value) {
        setParam(INCLUDEAVAILABILITY, value);
        return this;
    }


    public static final String MATCHTIMESERIES = "matchtimeseries";



    public FDSNStationQueryParams clearMatchTimeseries() {
        clearParam(MATCHTIMESERIES);
        return this;
    }

    /** Limit to metadata where selection criteria matches time series data availability.
     */
    @Option(names = { "--matchtimeseries" }, description="Limit to metadata where selection criteria matches time series data availability.")
    public FDSNStationQueryParams setMatchTimeseries(boolean value) {
        setParam(MATCHTIMESERIES, value);
        return this;
    }


    public static final String UPDATEDAFTER = "updatedafter";



    public FDSNStationQueryParams clearUpdatedAfter() {
        clearParam(UPDATEDAFTER);
        return this;
    }

    /** Limit to metadata updated after specified date; updates are data center specific.
     */
    @Option(names = { "--updatedafter" }, description="Limit to metadata updated after specified date; updates are data center specific.", converter=FloorISOTimeParser.class)
    public FDSNStationQueryParams setUpdatedAfter(Instant value) {
        setParam(UPDATEDAFTER, value);
        return this;
    }



    @Option(names = {"--box"}, description="constraining box as west/east/south/north", converter=BoxAreaParser.class)
    public FDSNStationQueryParams boxArea(BoxArea box) {
        return area(box.south, box.north, box.west, box.east);
    }

    public FDSNStationQueryParams area(float minLat, float maxLat, float minLon, float maxLon) {
        return setMinLatitude(minLat).setMaxLatitude(maxLat).setMinLongitude(minLon).setMaxLongitude(maxLon);
    }

    public FDSNStationQueryParams ring(float lat, float lon, float maxRadius) {
        return setLatitude(lat).setLongitude(lon).setMaxRadius(maxRadius);
    }

    @Option(names = {"--donut"}, description="constraining donut as lat/lon/minRadius/maxRadius", converter=DonutParser.class)
    public FDSNStationQueryParams donut(DonutArea donut) {
        return ring(donut.latitude, donut.longitude, donut.maxradius).setMinRadius(donut.minradius);
    }


    

    public static final String LEVEL_NETWORK = "network";

    public static final String LEVEL_STATION = "station";

    public static final String LEVEL_CHANNEL = "channel";

    public static final String LEVEL_RESPONSE = "response";

    @Override
    public String getServiceName() {
        return STATION_SERVICE;
    }

    public static final String STATION_SERVICE = "station";


}

